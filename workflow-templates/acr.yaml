name: (Dev) Container image build and push, optionally update flux config

on:
  workflow_dispatch:
    inputs:
      no-build:
        description: "Use an existing image instead of building a new"
        required: false
        default: "false"

      no-build-tag:
        description: "Existing image tag to use, e.g. '03-10-2022.210'"
        required: false
        default: "latest"
  push:
    branches:
      - $default-branch
    paths:
      - "src/**"
      - "!src/**/*.md"

jobs:
  dev:
    uses: miljodir/cp-workflow-templates/.github/workflows/acr.yaml@main # Set this to @github-tag, e.g @main to avoid unexpected behavior
    with:
      environment: dev # dev, test or production. this parameter is important to set correctly.
      image-name: testteam1/testapp1 # Format your images like this: teamname/appname . Use appname/appname if "team/workload" is not applicaable
      build-path: "./src" # path to your Dockerfile

      # OPTIONAL ARGUMENTS
      #dockerfile-path: ./src/Dockerfile # can be set if Dockerfile is not directly under build-path / build context
      #use-docker-cache: # defaults to 'false'. 'true' will build the container image on the self-hosted runner container, which is faster, but may not always work.
      k8s-repo: "wl-myteam" # Change me
      k8s-deploymentfile: "/fluxcd/dev/app.yaml" # auto update image in deployment yaml. Requires the github app permission to bypass branch protection
      #k8s-branchname: "main" # defaults to main
      #build-arg: "environment=dev"
      #run-image-scan: "false" # defaults to true
      #image-scan-severity: "MEDIUM" # defaults to "HIGH"
      no-build: ${{ github.event.inputs.no-build }} # only relevant for workflow_dispatch
      no-build-tag: ${{ github.event.inputs.no-build-tag }} # only relevant for workflow_dispatch
    secrets:
      acr-clientid: ${{ secrets.AZURE_CLIENT_ID }}
      acr-clientsecret: ${{ secrets.AZURE_CLIENT_SECRET }}
      pem: ${{ secrets.FLUXCD_PR_BYPASS_PEM }}
